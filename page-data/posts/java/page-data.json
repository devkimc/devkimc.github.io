{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/java","result":{"pageContext":{"currentCategory":"java","categories":["All","블로그","java","db","server","docker","spring","ci/cd","web","frontend"],"edges":[{"node":{"id":"3ff560ac-5a3b-5967-bcdf-7326deeb19d3","excerpt":"1. 최종 처리 스트림은 중간 처리, 최종 처리 과정을 거친 후에 결과값을 반환합니다.\n\n최종 처리는 중간 처리에서 정제된 요소들을 반복하거나, 집계(카운팅, 총합, 평균) 작업을 수행합니다. 주의할 점은 최종 처리를 꼭 해줘야 한다는 것입니다.\n\n최종 처리를 하지 않으면 중간처리도 동작하지 않습니다. 2. 최종 처리 종류 2.1 매칭 매칭은 요소들이 특정 조건을 만족하는지 여부를 조사하는 최종 처리 기능입니다.\n메서드는 , ,  가 있습니다. 매개값으로 주어진  가 리턴하는 값에 따라 boolean 값을 리턴합니다. 예시 Output 2.2 집계 집계는 요소들을 처리해서 카운팅, 합계, 평균값, 최대값, 최소값등과 같이 하나의 값으로 산출하는 최종 처리 기능입니다. , , , , , ,  가 있습니다. 예시 Output 2.3 수집 수집은 필터링 또는 매핑한 후 요소들을 수집하는 최종 처리 기능입니다.  메서드를 사용합니다.  메서드는  를 매개변수로 사용합니다. Collect<…","fields":{"slug":"/java-stream-terminal-operation/"},"frontmatter":{"categories":"블로그 java","title":"Java Stream 최종 처리","date":"August 21, 2023"}},"next":{"fields":{"slug":"/java-stream-intermediate-operation/"}},"previous":null},{"node":{"id":"05a80f1b-e52e-5b60-a512-5ac1df1e67a4","excerpt":"1. Java Stream Java 8부터 컬렉션 및 배열의 요소를 반복처리하기 위해 추가된 기능 2. Stream 특징 내부 반복자이므로 처리 속도가 빠르고 병렬 처리에 효율적이다. 람다식으로 다양한 요소 처리를 정의할 수 있다. 중간 처리와 최종 처리를 수행하도록 파이프 라인을 형성할 수 있다. 3. 중간 처리, 최종 처리 스트림은 중간 처리, 최종 처리 과정을 거친 후에 결과값을 반환합니다. 중간 처리는 요소를 걸러내거나(필터링), 요소를 변환시키거나(매핑), 정렬하는 자업을 수행합니다.\n\n최종 처리는 중간 처리에서 정제된 요소들을 반복하거나, 집계(카운팅, 총합, 평균) 작업을 수행합니다. 주의할 점은 최종 처리를 꼭 해줘야 한다는 것입니다.\n\n최종 처리를 하지 않으면 중간처리도 동작하지 않습니다. 예시로 사용할 Student 클래스입니다. Output 4. 스트림 생성 java.util.stream 패키지에는 스트림 인터페이스들이 있습니다. BaseStream 인터페이스를…","fields":{"slug":"/java-stream-intermediate-operation/"},"frontmatter":{"categories":"블로그 java","title":"Java Stream 중간 처리","date":"August 20, 2023"}},"next":{"fields":{"slug":"/java-list/"}},"previous":{"fields":{"slug":"/java-stream-terminal-operation/"}}},{"node":{"id":"7eb6d481-6bbc-5724-aeda-ed44a83b2207","excerpt":"1. Java list 요소를 순차적으로 저장하고 중복을 허용하는 데이터 집합입니다. java.util 패키지 내부에 있고, Collection 인터페이스의 하위 인터페이스입니다. 2. List 종류 2.1 ArrayList ArrayList는 배열을 기반으로 만들어진 자료구조입니다. 배열은 크기가 고정이지만, ArrayList는 동적으로 늘릴 수 있습니다. 검색을 할 경우 인덱스로 조회하기 때문에 속도가 빠릅니다.\n\n데이터 추가, 삭제를 할 경우 이후의 데이터를 복사 후 재정렬하기 때문에 빈번한 추가, 삭제에는 부적합합니다. Capacity 내부적으로 저장이 가능한 메모리 용량(Capacity)이 있으며 현재 사용 중인 공간의 크기(Size)가 있습니다.\n\n인스턴스의 capacity 값 이상을 저장하려고 할 때 더 큰 공간의 메모리를 새롭게 할당합니다.\n ArrayList 코드를 보면서 어떻게 구성되었고 동작하는지 확인해보겠습니다. 기본 가용량(DEFAULT_CAPACITY)은 …","fields":{"slug":"/java-list/"},"frontmatter":{"categories":"블로그 java","title":"Java List","date":"August 13, 2023"}},"next":{"fields":{"slug":"/java-set/"}},"previous":{"fields":{"slug":"/java-stream-intermediate-operation/"}}},{"node":{"id":"0c0ee1c7-dc71-53dc-a930-ba93d66aaa7a","excerpt":"1. Java set Set 컬렉션 클래스는 Set 인터페이스를 구현한 클래스입니다. Set 컬렉션 클래스는 요소의 저장 순서를 유지하지 않고, 같은 요소의 중복 저장을 허용하지 않습니다. 따라서 중복을 제거해야 하거나 저장 순서가 중요하지 않을 때 자주 사용하는 컬렉션 클래스입니다. 2. Map 종류  2.1 HashSet 해시 알고리즘을 사용하여 검색 속도가 빠르고, 내부적으로 HashMap 인스턴스를 이용하여 요소를 저장합니다. HashSet은 요소를 삽입할 때 이미 존재하는 요소인지 파악하기 위해 내부적으로 다음과 같은 과정을 거칩니다. 해당 요소에서  메서드를 호출해 반환된 해시 값으로 검색할 범위를 결정한다. 해당 범위 내의 요소들을  메서드로 비교한다. output 2.2 LinkedHashSet HashSet과 동일한 구조를 가지지만 삽입된 순서를 저장하는 Set 자료구조입니다. output 2.3 TreeSet TreeSet은 요소를 정렬해서 저장합니다. 내부적으로…","fields":{"slug":"/java-set/"},"frontmatter":{"categories":"블로그 java","title":"Java Set","date":"August 12, 2023"}},"next":{"fields":{"slug":"/java-map/"}},"previous":{"fields":{"slug":"/java-list/"}}},{"node":{"id":"26fddc3d-3773-56e0-be36-f410d8c117ee","excerpt":"1. Java map Java에서 Map 인터페이스는 java.util 패키지에 있으며 키와 값 간의 매핑을 나타냅니다. Collection 인퍼페이스와는 다른 저장방식을 가집니다. 맵은 사전과 같은 키-값 연결 매핑에 사용하기에 완벽합니다. 맵은 키로 조회를 수행하거나 키로 요소를 검색하고 업데이트하려고 할 때 사용됩니다. 2. Map 특징  맵은 중복 키를 포함할 수 없으며 각 키는 최대 하나의 값에 매핑할 수 있습니다. 저장 순서는 특정 구현에 따라 다릅니다. TreeMap과 LinkedHashMap은 예측 가능한 순서가 있지만, HashMap에는 순서가 없습니다. Java에서 map을 구현하기 위한 두 가지(Map, SortedMap) 인터페이스와 세 가지 클래스(HashMap, TreeMap 및 LinkedHashMap)가 있습니다. 3. Map 종류 3.1 HashMap HashMap은 해싱 기술을 사용합니다. 해싱은 큰 문자열을 동일한 문자열을 나타내는 작은 문자열로 …","fields":{"slug":"/java-map/"},"frontmatter":{"categories":"블로그 java","title":"Java Map","date":"August 12, 2023"}},"next":{"fields":{"slug":"/jvm-architecture/"}},"previous":{"fields":{"slug":"/java-set/"}}},{"node":{"id":"166da7d8-d97b-50ec-8576-0519f35dbf1f","excerpt":"1. JVM 이란? Java 프로그램이 실행되기 위해 필요한 런타임 환경을 제공하는 프로그램입니다. C와 같은 프로그래밍 언어에서는 코드는 먼저 플랫폼별 기계어로 컴파일됩니다. 이러한 언어를 컴파일 언어라고 합니다. 반면 javascript 및 python과 같은 언어에서는 컴퓨터가 코드를 컴파일하지 않고 직접 실행합니다. 이러한 언어를 인터프리터 언어라고 합니다. Java는 두 기술을 조합하여 사용합니다. 소스 코드는 먼저 바이트 코드로 컴파일 되어 클래스 파일을 생성합니다. 이 클래스 파일은 기본 플랫폼에 대한 JVM에 의해 해석됩니다. 모든 플랫폼 및 운영 체제에서 실행되는 모든 버전의 JVM에서 동일한 클래스 파일을 실행할 수 있습니다. 2. JVM의 동작 방식 자바 프로그램을 실행하면 JVM은 OS로부터 메모리를 할당받습니다. 자바 컴파일러가 자바 소스코드를 자바 바이트 코드로 컴파일 합니다. Class Loader는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 …","fields":{"slug":"/jvm-architecture/"},"frontmatter":{"categories":"블로그 java","title":"JVM의 내부 구조","date":"August 12, 2023"}},"next":{"fields":{"slug":"/unknown-system-variable-transaction-isolation/"}},"previous":{"fields":{"slug":"/java-map/"}}},{"node":{"id":"27531f53-e48a-590e-b237-b7cef8b88d47","excerpt":"⏰ 성능 이슈 발생 쿼리 메서드를 작성하고 의도한대로 작동했는지 확인하고 있었습니다.\n엔티티에 존재하는 applicant, group, status 필드를 조건으로 하여 데이터를 조회하는 쿼리 메서드입니다. Repository Entity  제가 의도한 동작 방식은 조인을 하지 않고 Subscription 엔티티의 필드만으로 데이터를 조회하는 것이었습니다.\nJoin 이 사용된 이유가 궁금했습니다. 🔍 성능 이슈 원인 의심이 됐던 원인은\n쿼리 메서드 작성 시, 조건으로 외래키(ApplicantId, GroupId) 값을 사용했고,\n엔티티에는 연관관계의 객체(User, Group)가 있다는 것입니다. 쿼리 메서드가 외래키를 읽지 못하고 join 이 발생한다?\n이렇게 생각하기에는 이해가 되지 않아서 쿼리메서드의 동작 과정을 찾아봤습니다. 쿼리 메서드 동작 과정 Property travelsal Property expressions can refer only to a direct prop…","fields":{"slug":"/select-query-method-join/"},"frontmatter":{"categories":"블로그 java","title":"조회 쿼리 메서드 사용 시 불필요한 Join 이 사용되는 이유","date":"July 03, 2023"}},"next":{"fields":{"slug":"/jpa-insert-before-select/"}},"previous":{"fields":{"slug":"/no-sql/"}}},{"node":{"id":"8d423b3a-2996-5462-b717-9113b0389e3d","excerpt":"⏰ 성능 이슈 발생 서비스 로직을 테스트 하는 중이었습니다. 클라이언트는 api 호출 시, naver map api 로 부터 조회 받은 식당 ID 값과 서버로 보내준다. 서버는 식당 ID 값과 추가 정보를 DB 에 저장한다. 간단한 로직이기에 문제는 없을 거라 생각했습니다. 그런데 식당 정보를 DB 에 저장할 때 select 쿼리가 호출됐습니다..  Insert 쿼리를 호출하기 전에 select 쿼리가 반복적으로 호출된다면, 클라이언트의 api 호출 수만큼 select 쿼리가 호출되는 것입니다. 서버에 불필요한 부하가 추가되는 로직이므로 수정이 필요했습니다. 🔍 성능 이슈 원인 save 엔티티를 저장하는 save 메서드는 아래 코드로 구현되어 있습니다.\n저장될 엔티티가 새로운 엔티티인지 확인합니다. 새로운 엔티티면 저장하고, 아니라면 merge 메서드로 업데이트 합니다. merge 영속 컨텍스트에서 merge 의 동작방식은 merge() 실행\n2. 엔티티의 식별자 값으로 1차 캐시…","fields":{"slug":"/jpa-insert-before-select/"},"frontmatter":{"categories":"블로그 java","title":"엔티티 저장 시 Select 쿼리를 호출 하는 이유","date":"June 21, 2023"}},"next":{"fields":{"slug":"/java-deploy-with-elastic-beanstalk-and-docker/"}},"previous":{"fields":{"slug":"/select-query-method-join/"}}},{"node":{"id":"bdd28560-f6c1-52b5-9196-098dec4472ef","excerpt":"🤔 적용 이유 AutoScaling, LoadBalancer EB를 사용해본 적은 없으나 사용율이 증가하면 scale out 했다가, 다시 줄어들면 scale in 을 할 수 있는 AutoScaling Group과 서버의 부하를 나누어 주는 LoadBalancer를 간편하게 설정할 수 있는 점이 장점으로 느껴졌습니다.\n다른 여러 장점은 사용해보기 전에는 와닿지 않아서 ‘사용해보고 느껴보자’ 해서 사용했습니다. ⚙️ 설정 방법 1. IAM 역할 추가 Elastic beanstalk(이하 EB) 의 환경을 구성하기 위해 각 역할에 권한이 필요합니다. 1.1 서비스 역할 EB를 서비스로 사용하므로 담당할 IAM 역할을 부여합니다.\nElastic Beanstalk 서비스 역할 관리  설정하지 않을 시, 다음과 같은 에러를 만나게 됩니다.. Configuration validation exception: Invalid option specification (Namespace: ‘aws:ela…","fields":{"slug":"/elastic-beanstalk-docker-java/"},"frontmatter":{"categories":"블로그 java docker","title":"Elastic Beanstalk + Docker + Java 설정","date":"June 19, 2023"}},"next":{"fields":{"slug":"/could-not-safety-identify-store-assignment-for-repository/"}},"previous":{"fields":{"slug":"/java-deploy-with-elastic-beanstalk-and-docker/"}}},{"node":{"id":"611398ab-c106-5ee5-8ae1-f0b337ba3884","excerpt":"📕 개념 ❌ 교착 상태(Deadlock) 노트북으로 코딩을 하고 싶은 두 사람 A, B(프로세스/스레드) 가 있다.\nA는 배터리가 0% 인 노트북(자원)을 가지고 있고(점유) 충전기 를 기다리고 있다(대기).\nB는 충전기(자원)를 가지고 있고(점유) 노트북을 기다리고 있다(대기). 이처럼 서로 자원을 놓아줄 생각은 없고, 자원 요청을 무한정 대기하고 있는 상태 를 말합니다. Critical section(임계 영역) 여기서 노트북과 충전기를 공유 자원이라고 부르고, 공유자원이 속해 있어 교착 상태가 발생할 수 있는 영역을 임계영역이라고 부릅니다.\n공유 데이터의 일관성을 보장하기 위해 하나의 프로세스/스레드만 진입해서 실행(상호배제)가능한 영역입니다. 교착 상태가 발생하기 위해서는 네가지 조건을 충족해야 합니다. 이중 상호배제를 중점으로 알아보려 합니다. 상호배제 점유대기 비선점 순환대기 Mutual exclusion(상호 배제) 프로세스/스레드가 필요로 하는 공유자원에 대해 배타적…","fields":{"slug":"/mutex-semaphore/"},"frontmatter":{"categories":"블로그 java","title":"뮤텍스(Mutex)와 세마포어(Semaphore)","date":"June 17, 2023"}},"next":{"fields":{"slug":"/spring-rest-docs/"}},"previous":{"fields":{"slug":"/could-not-safety-identify-store-assignment-for-repository/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}